package dadParticulas;

import java.util.Random;

import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
import io.netty.handler.codec.mqtt.MqttQoS;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.json.Json;
import io.vertx.mqtt.MqttClient;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.mqtt.impl.MqttClientImpl;
import tipos.ActuadorAlarmaValue;
import tipos.ActuadorLcdValue;
import tipos.Sensor_DHT11_value;
import tipos.Sensor_particula_value;

public class MqttClientVerticle extends AbstractVerticle {
	private static Boolean sync = new Boolean(true);
	private String classInstanceId;
	long i=0;
	public void start(Promise<Void> promise) {
		classInstanceId = this.hashCode() + "";
		MqttClientOptions options = new MqttClientOptions();
		options.setAutoKeepAlive(true);
		options.setAutoGeneratedClientId(false);
		options.setClientId(classInstanceId);
		options.setConnectTimeout(5000);
		options.setCleanSession(true);
		options.setKeepAliveTimeSeconds(10000);
		options.setReconnectAttempts(10);
		options.setReconnectInterval(5000);
		options.setUsername("mqttbroker");
		options.setPassword("mqttbrokerpass");
		MqttClient mqttClient = new MqttClientImpl(vertx, options);

		mqttClient.publishHandler(messageReceivedHandler -> {
			MqttMessageFormat mqttMessageFormat = new MqttMessageFormat(classInstanceId, messageReceivedHandler);
			synchronized (sync) {
				System.out.println("------------------ Begin message received ------------------");
				System.out.println(Json.encodePrettily(mqttMessageFormat));
				System.out.println("------------------ End message received ------------------");
			}

		});

		Random randomTimeSeconds = new Random();

		mqttClient.connect(1885, "localhost", handler -> {
			if (handler.result().code() == MqttConnectReturnCode.CONNECTION_ACCEPTED) {
				mqttClient.subscribe(MqttServerVerticle.TOPIC_SENSORES_PARTICULA_VALUE, MqttQoS.AT_LEAST_ONCE.value(),
						handlerSubscribe -> {
							if (handlerSubscribe.succeeded()) {
								System.out.println(classInstanceId + " subscribed to " + MqttServerVerticle.TOPIC_SENSORES_PARTICULA_VALUE
										+ " channel");

								vertx.setPeriodic((5 + randomTimeSeconds.nextInt(5)) * 1000, handlerPeriodic -> {
									
										
										Random random= new Random();
										
										Sensor_particula_value sensorParticulaValue = new Sensor_particula_value(1, 1, random.nextFloat()+10,random.nextFloat()+15, random.nextFloat()+16, (float)10.0, i);
											i=i+1000;
											mqttClient.publish(MqttServerVerticle.TOPIC_SENSORES_PARTICULA_VALUE,
													Buffer.buffer(Json.encodePrettily(sensorParticulaValue)), MqttQoS.AT_LEAST_ONCE, false, true);
								});
							} else {
								System.out.println(
										classInstanceId + " NOT subscribed to " + MqttServerVerticle.TOPIC_SENSORES_PARTICULA_VALUE
												+ " channel " + handlerSubscribe.cause().toString());
							}
						});
				mqttClient.subscribe(MqttServerVerticle.TOPIC_SENSORES_DHT11_VALUE, MqttQoS.AT_LEAST_ONCE.value(),
						handlerSubscribe -> {
							if (handlerSubscribe.succeeded()) {
								System.out.println(classInstanceId + " subscribed to " + MqttServerVerticle.TOPIC_SENSORES_DHT11_VALUE
										+ " channel");

								vertx.setPeriodic((5 + randomTimeSeconds.nextInt(5)) * 1000, handlerPeriodic -> {
									
										
										Random random= new Random();
										
										Sensor_DHT11_value sensorParticulaValue = new Sensor_DHT11_value(1, 1, random.nextInt(35), random.nextInt(100), (float)10.0,i);
										mqttClient.publish(MqttServerVerticle.TOPIC_SENSORES_DHT11_VALUE,
												Buffer.buffer(Json.encodePrettily(sensorParticulaValue)), MqttQoS.AT_LEAST_ONCE, false, true);	
								});
							} else {
								System.out.println(
										classInstanceId + " NOT subscribed to " + MqttServerVerticle.TOPIC_SENSORES_DHT11_VALUE
												+ " channel " + handlerSubscribe.cause().toString());
							}
						});

				

				mqttClient.subscribe(MqttServerVerticle.TOPIC_ACTUADORES_ALARMA_VALUE, MqttQoS.AT_LEAST_ONCE.value(), handlerSubscribe -> {
					if (handlerSubscribe.succeeded()) {
						System.out.println(
								classInstanceId + " subscribed to " + MqttServerVerticle.TOPIC_ACTUADORES_ALARMA_VALUE + " channel");
						vertx.setPeriodic((7 + randomTimeSeconds.nextInt(5)) * 1000, handlerPeriodic -> {
							
							Random random= new Random();
							ActuadorAlarmaValue actuadorAlarma = new ActuadorAlarmaValue(1, 1, 0+random.nextInt(1), random.nextLong()+10);
									
								

							mqttClient.publish(MqttServerVerticle.TOPIC_ACTUADORES_ALARMA_VALUE,
									Buffer.buffer(Json.encodePrettily(actuadorAlarma)), MqttQoS.AT_LEAST_ONCE, false, true);
						});

					} else {
						System.out.println(classInstanceId + " NOT subscribed to " + MqttServerVerticle.TOPIC_ACTUADORES_ALARMA_VALUE
								+ " channel " + handlerSubscribe.cause().toString());
					}
				});
				mqttClient.subscribe(MqttServerVerticle.TOPIC_ACTUADORES_LCD_VALUE, MqttQoS.AT_LEAST_ONCE.value(), handlerSubscribe -> {
					if (handlerSubscribe.succeeded()) {
						System.out.println(
								classInstanceId + " subscribed to " + MqttServerVerticle.TOPIC_ACTUADORES_LCD_VALUE + " channel");
						vertx.setPeriodic((7 + randomTimeSeconds.nextInt(5)) * 1000, handlerPeriodic -> {
							
							Random random= new Random();
							ActuadorLcdValue actuadorLCD = new ActuadorLcdValue(1, 1, "Si funciona", random.nextLong()+10);
									
								

							mqttClient.publish(MqttServerVerticle.TOPIC_ACTUADORES_LCD_VALUE,
									Buffer.buffer(Json.encodePrettily(actuadorLCD)), MqttQoS.AT_LEAST_ONCE, false, true);
						});

					} else {
						System.out.println(classInstanceId + " NOT subscribed to " + MqttServerVerticle.TOPIC_ACTUADORES_LCD_VALUE
								+ " channel " + handlerSubscribe.cause().toString());
					}
				});
			} else {
				System.out.println("Error: " + handler.result().code().toString());
			}
		});
	}

}
